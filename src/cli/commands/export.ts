/**
 * Export Command
 *
 * Download prompts from Studio and write to local files
 */

import { mkdir, writeFile, rename, rm, mkdtemp } from 'fs/promises';
import { join } from 'path';
import { tmpdir } from 'os';
import { loadConfig, resolveOutputDir } from '../utils/config.js';
import { createApiClient, type Prompt } from '../utils/api.js';

interface ExportOptions {
  tenantId?: string;
  serviceKey?: string;
  apiUrl?: string;
  promptName?: string;  // Optional: export single prompt by name
}

/**
 * Generate TypeScript file content for a prompt
 */
function generatePromptFile(prompt: Prompt): string {
  const header = `/**
 * ${prompt.promptName}
 *
 * ‚ö†Ô∏è  WARNING: This file is auto-generated by Studio CLI
 * ‚ö†Ô∏è  DO NOT EDIT MANUALLY - Changes will be overwritten
 * ‚ö†Ô∏è  Edit in Studio UI and run 'skej export' to update
 *
 * Category: ${prompt.category || 'general'}
 * Description: ${prompt.description || 'No description'}
 * Last Updated: ${prompt.updatedAt}
 */

`;

  const content = `export const ${sanitizeVariableName(prompt.promptName)} = ${JSON.stringify(
    {
      systemMessage: prompt.systemMessage,
      userMessage: prompt.userMessage,
      variables: prompt.variables,
      toolDefs: prompt.toolDefs,
      scenarios: prompt.scenarios || [],
      models: prompt.models,
      modelSampling: prompt.modelSampling || false,
    },
    null,
    2
  )};

export default ${sanitizeVariableName(prompt.promptName)};
`;

  return header + content;
}

/**
 * Sanitize prompt name for JavaScript variable name
 */
function sanitizeVariableName(name: string): string {
  // Convert to camelCase and remove invalid characters
  return name
    .replace(/[^a-zA-Z0-9_$]/g, '_')
    .replace(/^[0-9]/, '_$&')
    .replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Generate index file that exports all prompts
 */
function generateIndexFile(prompts: Prompt[]): string {
  const header = `/**
 * Studio Prompts Index
 *
 * ‚ö†Ô∏è  WARNING: This file is auto-generated by Studio CLI
 * ‚ö†Ô∏è  DO NOT EDIT MANUALLY - Changes will be overwritten
 *
 * Generated: ${new Date().toISOString()}
 * Total Prompts: ${prompts.length}
 */

`;

  const exports = prompts
    .map((p) => {
      const fileName = sanitizeFilename(p.promptName);
      const varName = sanitizeVariableName(p.promptName);
      return `export { default as ${varName} } from './${fileName}.js';`;
    })
    .join('\n');

  return header + exports + '\n';
}

/**
 * Sanitize prompt name for filename
 */
function sanitizeFilename(name: string): string {
  return name.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
}

/**
 * Export a single prompt by name
 */
async function exportSinglePrompt(
  client: any,
  config: any,
  promptName: string,
  apiMode: boolean = false
): Promise<void> {
  try {
    console.log(`üì• Exporting prompt: ${promptName}...`);
    console.log('');

    // Create output directory
    const outputDir = await resolveOutputDir(config.outputDir);
    await mkdir(outputDir, { recursive: true });

    // Export prompt from API
    // Skip version creation in apiMode (prompts loaded at runtime, not for version control)
    process.stdout.write(`   ‚¨áÔ∏è  ${promptName}...`);
    const createVersion = !apiMode;
    const exportResponse = await client.exportPrompt(promptName, createVersion);
    const prompt = exportResponse.data.manifest;

    const filename = sanitizeFilename(prompt.promptName);
    const filePath = join(outputDir, `${filename}.ts`);

    // Write to file
    const content = generatePromptFile(prompt);
    await writeFile(filePath, content, 'utf-8');

    process.stdout.write(` ‚úì\n`);
    console.log('');
    console.log(`‚úÖ Exported ${promptName} to ${filePath}`);
  } catch (error) {
    console.error('');
    console.error(`‚ùå Export failed: ${(error as Error).message}`);

    if ((error as Error).message.includes('404')) {
      console.error('');
      console.error(`Prompt "${promptName}" not found. Check the prompt name and try again.`);
    }

    process.exit(1);
  }
}

/**
 * Export prompts from Studio
 */
export async function exportCommand(options: ExportOptions): Promise<void> {
  try {
    // Load config from studio.config.js or CLI options
    let config = await loadConfig();

    // Check if config exists or required CLI options are provided
    if (!config) {
      if (!options.tenantId || !options.serviceKey) {
        console.error('‚ùå No config file found and required options not provided');
        console.error('');
        console.error('Either:');
        console.error('   1. Run: skej init');
        console.error('   2. Provide: --tenant-id and --service-key');
        process.exit(1);
      }

      // Use CLI options
      config = {
        tenantId: options.tenantId,
        serviceKey: options.serviceKey,
        apiUrl: options.apiUrl || 'https://api.skej.com',
        outputDir: './studio/prompts',
        apiMode: false,
      };
    }

    // Override config with CLI options if provided
    if (config) {
      if (options.tenantId) config.tenantId = options.tenantId;
      if (options.serviceKey) config.serviceKey = options.serviceKey;
      if (options.apiUrl) config.apiUrl = options.apiUrl;
    }

    console.log('üì¶ Exporting prompts from Studio...');
    console.log(`   Tenant: ${config.tenantId}`);
    console.log(`   API: ${config.apiUrl}`);
    console.log('');

    // Create API client
    const client = createApiClient({
      apiUrl: config.apiUrl,
      serviceKey: config.serviceKey,
      tenantId: config.tenantId,
    });

    // Handle single prompt export
    if (options.promptName) {
      await exportSinglePrompt(client, config, options.promptName, config.apiMode);
      return;
    }

    // Step 1: List all prompts
    console.log('üîç Fetching prompt list...');
    const promptList = await client.listPrompts();

    console.log(`‚úì Found ${promptList.data.length} prompts`);
    console.log('');

    if (promptList.data.length === 0) {
      console.log('‚úÖ No prompts to export');
      return;
    }

    // Create output directory
    const outputDir = await resolveOutputDir(config.outputDir);
    await mkdir(outputDir, { recursive: true });

    // Create temporary directory for atomic writes
    const tempDir = await mkdtemp(join(tmpdir(), 'skej-export-'));

    // Step 2: Download each prompt one by one
    console.log('üì• Downloading prompts...');
    let written = 0;
    const errors: string[] = [];
    const downloadedPrompts: Prompt[] = [];

    for (const item of promptList.data) {
      try {
        // Export prompt
        // Skip version creation in apiMode (prompts loaded at runtime, not for version control)
        process.stdout.write(`   ‚¨áÔ∏è  ${item.promptName}...`);
        const createVersion = !config.apiMode;
        const exportResponse = await client.exportPrompt(item.promptName, createVersion);
        const prompt = exportResponse.data.manifest;

        const filename = sanitizeFilename(prompt.promptName);
        const tempFilePath = join(tempDir, `${filename}.ts`);
        const finalFilePath = join(outputDir, `${filename}.ts`);

        // Write to temp file
        const content = generatePromptFile(prompt);
        await writeFile(tempFilePath, content, 'utf-8');

        // Atomic move: remove old file (if exists) and move temp to final location
        try {
          await rm(finalFilePath, { force: true });
        } catch {
          // File doesn't exist, ignore
        }

        await rename(tempFilePath, finalFilePath);

        downloadedPrompts.push(prompt);
        written++;
        process.stdout.write(` ‚úì\n`);
      } catch (error) {
        process.stdout.write(` ‚úó\n`);
        errors.push(`${item.promptName}: ${(error as Error).message}`);
      }
    }

    console.log('');

    // Generate index file
    if (downloadedPrompts.length > 0) {
      try {
        console.log('üìù Generating index file...');
        const tempIndexPath = join(tempDir, 'index.ts');
        const finalIndexPath = join(outputDir, 'index.ts');

        const indexContent = generateIndexFile(downloadedPrompts);
        await writeFile(tempIndexPath, indexContent, 'utf-8');

        // Atomic move for index file
        try {
          await rm(finalIndexPath, { force: true });
        } catch {
          // File doesn't exist, ignore
        }

        await rename(tempIndexPath, finalIndexPath);
        console.log('   ‚úì index.ts');
      } catch (error) {
        errors.push(`index.ts: ${(error as Error).message}`);
      }
    }

    // Clean up temp directory
    try {
      await rm(tempDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }

    console.log('');
    console.log(`‚úÖ Exported ${written}/${promptList.data.length} prompts to ${outputDir}`);

    if (errors.length > 0) {
      console.log('');
      console.log('‚ùå Errors:');
      errors.forEach((err) => console.log(`   ${err}`));
      process.exit(1);
    }
  } catch (error) {
    console.error('');
    console.error('‚ùå Export failed:', (error as Error).message);

    if ((error as Error).message.includes('401') || (error as Error).message.includes('403')) {
      console.error('');
      console.error('Authentication/Authorization failed. Please check:');
      console.error('   - Service key is valid (not revoked/expired)');
      console.error('   - Service key has "prompts:execute" scope');
      console.error('   - Tenant ID is correct');
    }

    process.exit(1);
  }
}
